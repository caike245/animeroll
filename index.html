<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Analisador de Gosto de Anime</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- jsPDF Library for PDF generation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'primary': '#1D4ED8', /* Azul mais forte */
                        'secondary': '#6C757D',
                        'dark': '#1F2937', /* Cinza escuro */
                        'success': '#10B981', /* Verde vibrante */
                        'danger': '#F87171', /* Vermelho suave */
                        'warning': '#FCD34D', /* Amarelo (para sugest√µes) */
                        'info': '#3B82F6', /* Azul claro (previs√£o) */
                    },
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap');
        .scroll-hidden::-webkit-scrollbar {
            display: none;
        }
        .scroll-hidden {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
        .modal {
            transition: opacity 0.3s ease-in-out;
        }
        /* Estilo da aba ativa */
        .tab-button.active {
            border-bottom: 3px solid #1D4ED8;
            color: #1D4ED8;
            font-weight: 700;
        }
        /* Estilo para range slider */
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: #1D4ED8;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
        }
        input[type=range]::-moz-range-thumb {
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: #1D4ED8;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen flex items-center justify-center p-4 font-sans">

    <!-- Principal Container -->
    <div id="app-container" class="bg-white p-6 md:p-10 rounded-2xl shadow-3xl w-full max-w-lg border border-gray-200">
        <h1 class="text-3xl font-extrabold text-center text-dark mb-6 border-b-2 pb-2 border-primary">
            Analisador de Gosto de Anime ‚ú®
        </h1>
        
        <!-- Estado Inicial / Carregando -->
        <div id="loading-state" class="text-center p-8 hidden">
            <div class="animate-spin rounded-full h-10 w-10 border-b-2 border-primary mx-auto mb-4"></div>
            <p class="text-secondary">Conectando ao banco de dados...</p>
        </div>

        <!-- Passo 1: In√≠cio e Bot√£o para Perguntas -->
        <div id="start-screen" class="text-center p-4">
            <h2 class="text-2xl font-bold text-primary mb-4">Bem-vindo(a) ao Seu Guia Anime!</h2>
            <p class="text-gray-600 mb-6">Escolha a profundidade do question√°rio para criar seu filtro:</p>
            
            <form id="quiz-level-form" class="mb-6 space-y-3">
                
                <div class="p-3 border border-gray-300 rounded-xl hover:bg-gray-100 text-left transition duration-200 shadow-sm">
                    <label class="inline-flex items-center w-full">
                        <input type="radio" name="quiz_level" value="simple" checked class="form-radio text-primary h-5 w-5">
                        <span class="ml-3 text-dark font-medium">1. Simples (10 Animes)</span>
                        <span class="ml-auto text-info cursor-pointer hover:text-blue-700" onclick="showExplanation('simple')">
                            <span class="font-bold">i</span>
                        </span>
                    </label>
                </div>

                <div class="p-3 border border-gray-300 rounded-xl hover:bg-gray-100 text-left transition duration-200 shadow-sm">
                    <label class="inline-flex items-center w-full">
                        <input type="radio" name="quiz_level" value="normal" class="form-radio text-primary h-5 w-5">
                        <span class="ml-3 text-dark font-medium">2. Normal (20 Animes)</span>
                        <span class="ml-auto text-info cursor-pointer hover:text-blue-700" onclick="showExplanation('normal')">
                            <span class="font-bold">i</span>
                        </span>
                    </label>
                </div>
                
                <div class="p-3 border border-gray-300 rounded-xl hover:bg-gray-100 text-left transition duration-200 shadow-sm">
                    <label class="inline-flex items-center w-full">
                        <input type="radio" name="quiz_level" value="pro" class="form-radio text-primary h-5 w-5">
                        <span class="ml-3 text-dark font-medium">3. Pro (50 Animes)</span>
                        <span class="ml-auto text-info cursor-pointer hover:text-blue-700" onclick="showExplanation('pro')">
                            <span class="font-bold">i</span>
                        </span>
                    </label>
                </div>

            </form>

            <button onclick="startQuiz(document.querySelector('input[name=quiz_level]:checked').value)" class="bg-primary hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-full shadow-lg transition duration-300 transform hover:scale-105">
                Come√ßar o Question√°rio
            </button>
            
            <p id="user-id-display" class="mt-4 text-sm text-gray-400"></p>
        </div>

        <!-- Passo 2: Question√°rio (Filtro) -->
        <div id="quiz-screen" class="hidden">
            <h2 class="text-xl font-semibold text-dark mb-4">Etapa 1: Avalie de 0 a 10</h2>
            <p class="text-sm text-gray-500 mb-6">0 = Odiou | 10 = Amou</p>
            <form id="quiz-form" onsubmit="event.preventDefault(); submitRatings()">
                <!-- Perguntas geradas aqui por JS -->
            </form>
            <button id="submit-button" onclick="submitRatings()" class="w-full bg-success hover:bg-green-700 text-white font-bold py-3 px-6 rounded-xl shadow-lg mt-6 transition duration-300 transform hover:scale-[1.01]">
                Gerar Meu Filtro!
            </button>
        </div>

        <!-- Passo 3: Abas de Navega√ß√£o e Conte√∫do -->
        <div id="main-tabs-screen" class="hidden">
            <div class="flex border-b border-gray-200 mb-6">
                <button class="tab-button p-3 flex-1 text-center text-secondary hover:text-dark transition duration-150 active" onclick="changeTab('prediction')">
                    Previs√£o ‚≠ê
                </button>
                <button class="tab-button p-3 flex-1 text-center text-secondary hover:text-dark transition duration-150" onclick="changeTab('list')">
                    Lista Assistidos ‚úÖ
                </button>
                 <button class="tab-button p-3 flex-1 text-center text-secondary hover:text-dark transition duration-150" onclick="changeTab('block')">
                    Bloqueio üö´
                </button>
            </div>
            
            <!-- Conte√∫do da Aba 1: Previs√£o (e Bot√£o Recome√ßar) -->
            <div id="prediction-tab-screen" class="tab-content">
                <h2 class="text-2xl font-semibold text-dark mb-4">An√°lise R√°pida</h2>
                <p class="text-gray-600 mb-6">Digite o nome de qualquer anime para prever se voc√™ vai gostar dele, ou pe√ßa uma sugest√£o personalizada!</p>
                
                <input type="text" id="anime-input" placeholder="Ex: Spy x Family" class="w-full p-3 border border-gray-300 rounded-xl focus:outline-none focus:border-primary mb-4 shadow-inner">
                
                <button onclick="predictAnime()" class="w-full bg-info hover:bg-blue-600 text-white font-bold py-3 px-6 rounded-xl shadow-md transition duration-300">
                    Prever Gosto
                </button>

                <!-- NOVO BOT√ÉO DE RECOMENDA√á√ÉO -->
                <button onclick="recommendAnime()" class="w-full bg-warning hover:bg-yellow-500 text-dark font-bold py-3 px-6 rounded-xl shadow-md transition duration-300 mt-4">
                    Sugest√£o Aleat√≥ria de Anime (Match! üí•)
                </button>

                <!-- √Årea de Resultado da Predi√ß√£o -->
                <div id="prediction-result" class="mt-6 p-4 border border-gray-300 rounded-xl shadow-inner bg-gray-50 hidden">
                    <h3 class="text-xl font-bold mb-2" id="prediction-title"></h3>
                    <p id="prediction-score" class="text-3xl font-extrabold mb-2 text-primary"></p>
                    <p id="prediction-justification" class="text-gray-700"></p>
                    <div id="loading-prediction" class="hidden text-center mt-4">
                        <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-info mx-auto mb-2"></div>
                        <p id="prediction-loading-message" class="text-info text-sm">üîç Analisando o anime (usando o Sistema de An√°lise e Busca)...</p>
                    </div>
                </div>

                <!-- BOT√£o RECOME√áAR QUESTION√ÅRIO MOVIDO PARA C√Å -->
                <div class="mt-8 pt-4 border-t border-gray-200">
                    <p class="text-sm text-secondary mb-2">Se voc√™ quiser redefinir seu perfil, clique abaixo:</p>
                    <button onclick="resetApp()" class="w-full bg-secondary hover:bg-gray-700 text-white font-bold py-2 px-6 rounded-xl transition duration-300 shadow-md">
                        Recome√ßar Question√°rio
                    </button>
                </div>
            </div>
            
            <!-- Conte√∫do da Aba 2: Lista de Assistidos e Gerenciamento -->
            <div id="list-tab-screen" class="tab-content hidden">
                <h2 class="text-2xl font-semibold text-dark mb-4">Gerenciamento de Lista</h2>
                <p class="text-gray-600 mb-6">Mantenha sua lista de assistidos atualizada para sugest√µes mais precisas.</p>
                
                <!-- Lista de Animes Assistidos (Resumo) -->
                <div class="pt-4 border-t border-gray-200">
                    <div class="flex justify-between items-center mb-2">
                        <h3 id="watched-count" class="text-lg font-semibold text-dark">Animes Assistidos (0):</h3>
                        <button onclick="openWatchedListModal()" class="text-sm text-primary font-semibold hover:text-blue-700 transition duration-300">
                            Ver/Gerenciar Lista Completa
                        </button>
                    </div>
                    
                    <ul id="watched-list" class="flex flex-wrap gap-2 text-gray-700 max-h-32 overflow-y-auto scroll-hidden p-1 border border-gray-200 rounded-lg bg-gray-50">
                        <!-- Lista de animes assistidos (resumo) ser√° renderizada aqui -->
                    </ul>
                </div>
                
                <!-- Fun√ß√µes de Gerenciamento da Lista (Import/Export) -->
                <div class="mt-6 pt-4 border-t border-gray-200">
                    <h3 class="text-lg font-semibold text-dark mb-3">Importa√ß√£o e Exporta√ß√£o</h3>
                    
                    <button onclick="exportWatchedList()" class="w-full bg-secondary hover:bg-gray-700 text-white font-bold py-2 px-6 rounded-xl transition duration-300 shadow-md mb-2">
                        Exportar Lista (Copiar para √Årea de Transfer√™ncia)
                    </button>

                    <!-- NOVO BOT√ÉO DE EXPORTA√á√ÉO PARA PDF -->
                    <button onclick="exportToPDF()" class="w-full bg-primary hover:bg-blue-700 text-white font-bold py-2 px-6 rounded-xl transition duration-300 shadow-md mb-4">
                        Exportar para PDF (Download)
                    </button>
                    

                    <!-- √Årea de Importa√ß√£o em Massa -->
                    <textarea id="batch-anime-input" placeholder="Cole uma lista de animes aqui (um por linha, separados por v√≠rgula, etc.)" maxlength="15000" class="w-full p-3 border border-gray-300 rounded-xl focus:outline-none focus:border-primary mb-1 h-24 shadow-inner" oninput="updateCharCounter()"></textarea>
                    
                    <p class="text-xs mb-3 flex justify-between">
                        <span id="char-count" class="text-gray-500">0 / 15.000 caracteres</span>
                        <span class="text-right text-gray-500">Limite de 15.000 caracteres para garantir o processamento.</span>
                    </p>

                    <button onclick="batchAddWatchedAnimes()" class="w-full bg-primary hover:bg-blue-700 text-white font-bold py-2 px-6 rounded-xl transition duration-300 shadow-md">
                        Adicionar V√°rios Animes
                    </button>
                </div>
            </div>

            <!-- Conte√∫do da Aba 3: Lista de Bloqueio (NOVO) -->
            <div id="block-tab-screen" class="tab-content hidden">
                <h2 class="text-2xl font-semibold text-dark mb-4">Lista de Bloqueio</h2>
                <p class="text-gray-600 mb-6">Estes animes NUNCA ser√£o sugeridos novamente.</p>
                
                <div class="pt-4 border-t border-gray-200">
                    <div class="flex justify-between items-center mb-2">
                        <h3 id="blocked-count" class="text-lg font-semibold text-dark">Animes Bloqueados (0):</h3>
                        <button onclick="openBlockListModal()" class="text-sm text-danger font-semibold hover:text-red-600 transition duration-300">
                            Ver/Gerenciar Lista Completa
                        </button>
                    </div>
                    
                    <ul id="blocked-list-summary" class="flex flex-wrap gap-2 text-gray-700 max-h-32 overflow-y-auto scroll-hidden p-1 border border-gray-200 rounded-lg bg-red-50">
                        <!-- Resumo dos animes bloqueados -->
                    </ul>
                </div>

                 <div class="mt-6 pt-4 border-t border-gray-200">
                    <h3 class="text-lg font-semibold text-dark mb-3">Bloquear um Anime</h3>
                    <input type="text" id="manual-block-input" placeholder="Digite o nome do anime para bloquear" class="w-full p-3 border border-gray-300 rounded-xl focus:outline-none focus:border-danger mb-3 shadow-inner">
                    <button onclick="blockAnimeFromInput()" class="w-full bg-danger hover:bg-red-600 text-white font-bold py-2 px-6 rounded-xl transition duration-300 shadow-md">
                        Bloquear Manualmente
                    </button>
                </div>
            </div>

        </div>
    </div>

    <!-- Modal de Gerenciamento da Lista de Assistidos -->
    <div id="watched-list-modal" class="modal fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center p-4 z-50 hidden">
        <div class="bg-white p-6 rounded-xl shadow-2xl w-full max-w-md max-h-[80vh] overflow-y-auto transform scale-95 transition-transform duration-300">
            <div class="flex justify-between items-center mb-4 border-b pb-2">
                <h2 class="text-2xl font-bold text-dark">Minha Lista de Assistidos</h2>
                <button onclick="closeWatchedListModal()" class="text-gray-500 hover:text-gray-800 text-2xl font-bold">
                    &times;
                </button>
            </div>
            
            <!-- CAMPO DE BUSCA ADICIONADO AQUI -->
            <input type="text" id="watched-list-search" oninput="filterWatchedList()" placeholder="Buscar anime na lista..." class="w-full p-2 border border-gray-300 rounded-xl focus:outline-none focus:border-primary mb-4 shadow-inner">

            <p class="text-sm text-gray-600 mb-4">Clique no **X** para remover um anime da sua lista.</p>

            <!-- Lista Detalhada com Bot√µes de Remo√ß√£o -->
            <ul id="detailed-watched-list" class="space-y-3">
                <!-- Animes e bot√µes de remo√ß√£o ser√£o renderizados aqui -->
            </ul>

            <button onclick="closeWatchedListModal()" class="w-full bg-primary hover:bg-blue-700 text-white font-bold py-2 px-6 rounded-xl mt-6 transition duration-300 shadow-md">
                Fechar
            </button>
        </div>
    </div>
    
     <!-- Modal de Gerenciamento da Lista de Bloqueio (NOVO) -->
    <div id="block-list-modal" class="modal fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center p-4 z-50 hidden">
        <div class="bg-white p-6 rounded-xl shadow-2xl w-full max-w-md max-h-[80vh] overflow-y-auto transform scale-95 transition-transform duration-300">
            <div class="flex justify-between items-center mb-4 border-b pb-2">
                <h2 class="text-2xl font-bold text-dark">Animes Bloqueados</h2>
                <button onclick="closeBlockListModal()" class="text-gray-500 hover:text-gray-800 text-2xl font-bold">
                    &times;
                </button>
            </div>
            
            <!-- CAMPO DE BUSCA ADICIONADO AQUI -->
            <input type="text" id="block-list-search" oninput="filterBlockList()" placeholder="Buscar anime bloqueado..." class="w-full p-2 border border-gray-300 rounded-xl focus:outline-none focus:focus:border-danger mb-4 shadow-inner">

            <p class="text-sm text-gray-600 mb-4">Clique no **X** para DESBLOQUEAR um anime (e permitir que ele seja sugerido novamente).</p>

            <!-- Lista Detalhada com Bot√µes de Remo√ß√£o -->
            <ul id="detailed-block-list" class="space-y-3">
                <!-- Animes e bot√µes de remo√ß√£o ser√£o renderizados aqui -->
            </ul>

            <button onclick="closeBlockListModal()" class="w-full bg-primary hover:bg-blue-700 text-white font-bold py-2 px-6 rounded-xl mt-6 transition duration-300 shadow-md">
                Fechar
            </button>
        </div>
    </div>


    <!-- Modal de Explica√ß√£o de N√≠vel do Quiz -->
    <div id="explanation-modal" class="modal fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center p-4 z-50 hidden">
        <div class="bg-white p-6 rounded-xl shadow-2xl w-full max-w-md transform scale-95 transition-transform duration-300">
            <div class="flex justify-between items-center mb-4 border-b pb-2">
                <h2 class="text-2xl font-bold text-dark" id="explanation-title"></h2>
                <button onclick="closeExplanationModal()" class="text-gray-500 hover:text-gray-800 text-2xl font-bold">
                    &times;
                </button>
            </div>
            <p id="explanation-content" class="text-gray-700"></p>
            <button onclick="closeExplanationModal()" class="w-full bg-primary hover:bg-blue-700 text-white font-bold py-2 px-6 rounded-xl mt-6 transition duration-300">
                Entendi
            </button>
        </div>
    </div>

    <!-- Global Loading Overlay (Para salvar e importar dados) -->
    <div id="global-loading-overlay" class="modal fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center p-4 z-50 hidden">
        <div class="bg-white p-6 rounded-xl shadow-2xl text-center">
            <!-- √çCONE DE LOADING TEM√ÅTICO (EXPLOS√ÉO M√ÅGICA) -->
            <p class="text-4xl animate-pulse mx-auto mb-4">‚ú®</p>
            <div class="animate-spin rounded-full h-10 w-10 border-b-2 border-primary mx-auto mb-4 opacity-50"></div>
            <p id="global-loading-message" class="text-dark font-semibold">Processando...</p>
        </div>
    </div>


    <!-- Firebase Imports -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        // Importa m√≥dulos necess√°rios
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc, onSnapshot } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // =========================================================================
        // === CONFIGURA√á√ÉO FIREBASE PARA AMBIENTE DE PRODU√á√ÉO (GITHUB PAGES, ETC) ===
        // === SUAS CREDENCIAIS FORAM INSERIDAS AQUI ===
        // =========================================================================
        
        // 1. CONFIGURA√á√ÉO REAL DO PROJETO 'aniroll' (SEUS VALORES REAIS)
        const FIREBASE_CONFIG = {
            apiKey: "AIzaSyD9AszWm6oX4aLUP-tdw-JZ_1t2opJqaiE",
            authDomain: "aniroll.firebaseapp.com",
            projectId: "aniroll",
            storageBucket: "aniroll.firebasestorage.app",
            messagingSenderId: "371586778565",
            appId: "1:371586778565:web:106c4d5bf3a14ef3fe37ac",
            measurementId: "G-ZNJNWCMNNN"
        };

        // 2. Chave da API de An√°lise (Gemini) - CHAVE CORRIGIDA!
        const GEMINI_API_KEY = "AIzaSyDxjWn_xkqtO61bdKCY_kFPpHEqDECs0xg"; 
        
        // 3. O ID do Aplicativo (usado no caminho do Firestore)
        const appId = FIREBASE_CONFIG.projectId || 'default-app-id'; 
        
        let app, db, auth, userId = 'guest';
        let userFilter = null;
        let isAuthReady = false;
        let watchedAnimes = []; // Lista de animes assistidos
        let blockedAnimes = []; // NOVO: Lista de animes bloqueados
        let currentQuizData = []; // Armazena o subset de animes do quiz
        let activeTab = 'prediction'; // Estado da aba ativa

        setLogLevel('Debug');

        // --- Dados do Question√°rio (Expandidos para 50 animes) ---
        const allQuizData = [
            // 1-10: Foco em A√ß√£o, Sombrio, Com√©dia, Esportes, Filtros de Bloqueio (Base Simples)
            { name: "Attack on Titan", tags: ["A√ß√£o", "Fantasia Sombria", "Alto Risco", "Psicol√≥gico"], description: "A√ß√£o intensa, mist√©rio complexo e drama de guerra." },
            { name: "Re:Zero - Starting Life in Another World", tags: ["Isekai", "Fantasia Sombria", "Psicol√≥gico", "Alto Risco"], description: "Isekai com foco em sofrimento psicol√≥gico e consequ√™ncias." },
            { name: "Hunter x Hunter (2011)", tags: ["A√ß√£o", "Shonen", "Estrat√©gia", "Regras Complexas"], description: "Aventura Shonen que valoriza a intelig√™ncia e estrat√©gia." },
            { name: "Spy x Family", tags: ["Com√©dia", "Slice of Life", "A√ß√£o Leve"], description: "Com√©dia leve, familiar e de alta qualidade de produ√ß√£o." },
            { name: "Fullmetal Alchemist: Brotherhood", tags: ["A√ß√£o", "Fantasia", "Aventura", "Enredo Coerente"], description: "Aventura √©pica com personagens cativantes e um plot fechado." },
            { name: "Made in Abyss", tags: ["Aventura", "Horror Corporal", "Fantasia Sombria"], description: "Come√ßa fofo, mas se torna grotesco e psicologicamente perturbador (Filtro de Bloqueio)." },
            { name: "Odd Taxi", tags: ["Thriller", "Di√°logo Lento", "Mist√©rio"], description: "Thriller focado em di√°logos, ritmo lento e mist√©rio urbano (Filtro de Bloqueio)." },
            { name: "One Punch Man", tags: ["Com√©dia", "A√ß√£o", "Shonen"], description: "Par√≥dia de super-her√≥i com a√ß√£o de alta qualidade e com√©dia inteligente." },
            { name: "Haikyu!!", tags: ["Esportes", "Drama", "Slice of Life"], description: "Foco intenso em esportes, trabalho em equipe e emo√ß√£o." },
            { name: "Vinland Saga", tags: ["A√ß√£o", "Hist√≥rico", "Drama", "Psicol√≥gico"], description: "A√ß√£o viking e drama profundo sobre vingan√ßa e desenvolvimento de personagem." },
            
            // 11-20: Adiciona Sci-Fi, Romance, Mecha, mais variedade (N√≠vel Normal)
            { name: "Code Geass", tags: ["Mecha", "Suspense", "Estrat√©gia", "Alto Risco"], description: "Estrat√©gia militar e dilemas morais em um futuro com rob√¥s gigantes." },
            { name: "Jujutsu Kaisen", tags: ["A√ß√£o", "Sobrenatural", "Shonen", "Fantasia Sombria"], description: "A√ß√£o moderna com maldi√ß√µes e um sistema de poder din√¢mico." },
            { name: "Steins;Gate", tags: ["Sci-Fi", "Mist√©rio", "Thriller"], description: "Viagem no tempo e consequ√™ncias dram√°ticas em um thriller cient√≠fico." },
            { name: "Kaguya-sama: Love Is War", tags: ["Com√©dia", "Romance", "Slice of Life"], description: "Com√©dia rom√¢ntica de estrat√©gia e guerra mental entre estudantes." },
            { name: "Cowboy Bebop", tags: ["Sci-Fi", "Aventura", "A√ß√£o"], description: "Aventura espacial com um ton jazz√≠stico e epis√≥dios auto-contidos." },
            { name: "Violet Evergarden", tags: ["Drama", "Slice of Life", "Emocional"], description: "Foco intenso em desenvolvimento emocional e hist√≥rias humanas." },
            { name: "Monster", tags: ["Psicol√≥gico", "Thriller", "Mist√©rio"], description: "Thriller investigativo maduro, com foco em moralidade e suspense." },
            { name: "Demon Slayer: Kimetsu no Yaiba", tags: ["A√ß√£o", "Fantasia", "Shonen"], description: "A√ß√£o de fantasia visualmente impressionante e foco familiar." },
            { name: "Your Name (Kimi no Na wa)", tags: ["Romance", "Drama", "Sobrenatural"], description: "Drama rom√¢ntico emocional com elementos sobrenaturais." },
            { name: "Mushishi", tags: ["Sobrenatural", "Di√°logo Lento", "Contemplativo"], description: "S√©rie calma e epis√≥dica focada em criaturas m√≠sticas (Filtro de Bloqueio Leve)." },
            
            // 21-50: Aprofundamento em nichos e elementos narrativos (N√≠vel Pr√≥)
            { name: "Erased (Boku Dake ga Inai Machi)", tags: ["Mist√©rio", "Thriller", "Psicol√≥gico"], description: "Viagem no tempo e suspense para evitar trag√©dias do passado." },
            { name: "Psycho-Pass", tags: ["Sci-Fi", "Policial", "Suspense", "Psicol√≥gico"], description: "Pol√≠cia futurista que mede o coeficiente de crime das pessoas." },
            { name: "Mob Psycho 100", tags: ["A√ß√£o", "Com√©dia", "Sobrenatural", "Slice of Life"], description: "A√ß√£o com poderes ps√≠quicos e foco no crescimento emocional do protagonista." },
            { name: "Baccano!", tags: ["A√ß√£o", "Mist√©rio", "Hist√≥rico", "Sobrenatural"], description: "Enredo complexo e n√£o-linear com imortalidade e m√°fia nos EUA." },
            { name: "Samurai Champloo", tags: ["Aventura", "A√ß√£o", "Hist√≥rico", "Com√©dia"], description: "Aventura com espadas, hip-hop e epis√≥dios auto-contidos." },
            { name: "Slam Dunk", tags: ["Esportes", "Com√©dia", "Shonen"], description: "Um dos cl√°ssicos de esportes, focado em basquete e desenvolvimento de equipe." },
            { name: "Anohana (Ano Hi Mita Hana...)", tags: ["Drama", "Emocional", "Slice of Life"], description: "Drama sobre amizade de inf√¢ncia e luto, com elementos sobrenaturais." },
            { name: "Toradora!", tags: ["Romance", "Com√©dia", "Slice of Life"], description: "Com√©dia rom√¢ntica escolar focada em mal-entendidos e crescimento m√∫tuo." },
            { name: "Clannad", tags: ["Drama", "Emocional", "Romance", "Slice of Life"], description: "Drama colegial conhecido por sua intensidade emocional." },
            { name: "Angel Beats!", tags: ["A√ß√£o", "Drama", "Sobrenatural", "Emocional"], description: "Batalhas em um mundo p√≥s-vida com forte carga dram√°tica." },
            { name: "Assassination Classroom", tags: ["A√ß√£o", "Com√©dia", "Vida Escolar"], description: "Alunos tentando assassinar seu professor alien√≠gena antes que ele destrua a Terra." },
            { name: "Plastic Memories", tags: ["Sci-Fi", "Drama", "Romance", "Emocional"], description: "Romance agridoce em um futuro com andr√≥ides de vida limitada." },
            { name: "Akame ga Kill!", tags: ["A√ß√£o", "Fantasia Sombria", "Alto Risco"], description: "A√ß√£o com grupo de assassinos em um mundo de corrup√ß√£o e alta mortalidade." },
            { name: "Tengen Toppa Gurren Lagann", tags: ["Mecha", "A√ß√£o", "Aventura", "Enredo Coerente"], description: "Aventura √©pica de propor√ß√µes c√≥smicas com a√ß√£o exagerada." },
            { name: "A Silent Voice (Koe no Katachi)", tags: ["Drama", "Escolar", "Emocional"], description: "Drama profundo sobre bullying, comunica√ß√£o e reden√ß√£o." },
            { name: "No Game No Life", tags: ["Isekai", "Fantasia", "Estrat√©gia", "Com√©dia"], description: "Isekai onde todos os conflitos s√£o resolvidos atrav√©s de jogos." },
            { name: "Log Horizon", tags: ["Isekai", "Estrat√©gia", "Aventura"], description: "Isekai focado em constru√ß√£o de sociedade e estrat√©gia de jogo." },
            { name: "Black Clover", tags: ["Shonen", "Fantasia", "A√ß√£o"], description: "Shonen de fantasia cl√°ssico com crescimento de poder e foco em supera√ß√£o." },
            { name: "The Promised Neverland", tags: ["Mist√©rio", "Psicol√≥gico", "Alto Risco"], description: "Suspense psicol√≥gico sobre crian√ßas que tentam escapar de um orfanato." },
            { name: "Puella Magi Madoka Magica", tags: ["Fantasia Sombria", "Psicol√≥gico", "Alto Risco"], description: "Desconstru√ß√£o do g√™nero 'garota m√°gica' com temas sombrios e filos√≥ficos." },
            { name: "Hellsing Ultimate", tags: ["A√ß√£o", "Horror", "Fantasia Sombria", "Sobrenatural"], description: "A√ß√£o de vampiros com terror gr√°fico e produ√ß√£o de alta qualidade." },
            { name: "Legend of the Galactic Heroes", tags: ["Sci-Fi", "Estrat√©gia", "Drama", "Pol√≠tico"], description: "√ìpera espacial espacial focada em batalhas t√°ticas e pol√≠tica gal√°ctica." },
            { name: "March Comes In Like a Lion", tags: ["Slice of Life", "Psicol√≥gico", "Estrat√©gia"], description: "Drama introspectivo sobre um jogador profissional de shogi." },
            { name: "Spice and Wolf", tags: ["Aventura", "Fantasia", "Romance", "Di√°logo Lento"], description: "Aventura de fantasia focada em economia e di√°logos inteligentes." },
            { name: "Chainsaw Man", tags: ["A√ß√£o", "Fantasia Sombria", "Alto Risco", "Com√©dia"], description: "A√ß√£o sangrenta e sombria com humor c√≠nico e temas de horror." },
            { name: "FLCL", tags: ["A√ß√£o", "Com√©dia", "Sci-Fi", "Absurdo"], description: "S√©rie curta e ca√≥tica com anima√ß√£o experimental e nonsense." },
            { name: "Death Parade", tags: ["Psicol√≥gico", "Drama", "Sobrenatural"], description: "Julgamento de almas em um bar misterioso, com foco em dilemas morais." },
            { name: "Run with the Wind", tags: ["Esportes", "Drama", "Emocional"], description: "Drama de corrida com foco profundo no desenvolvimento dos personagens." },
            { name: "Fire Force", tags: ["Shonen", "A√ß√£o", "Sobrenatural"], description: "A√ß√£o de combate a fogo com poderes e um mist√©rio de fundo." },
            { name: "One Piece", tags: ["A√ß√£o", "Aventura", "Shonen", "Enredo Coerente"], description: "Aventura √©pica de longa dura√ß√£o com foco em amizade e liberdade." },
        ];


        // Mapeamento de G√™neros/Elementos para Pesos
        const tagWeights = {
            "A√ß√£o": 0, "Fantasia Sombria": 0, "Alto Risco": 0, "Psicol√≥gico": 0,
            "Isekai": 0, "Shonen": 0, "Estrat√©gia": 0, "Regras Complexas": 0,
            "Com√©dia": 0, "Slice of Life": 0, "A√ß√£o Leve": 0, "Fantasia": 0,
            "Aventura": 0, "Enredo Coerente": 0, "Thriller": 0, "Mist√©rio": 0,
            "Horror Corporal": 0, "Di√°logo Lento": 0, "Hist√≥rico": 0, "Mecha": 0,
            "Sci-Fi": 0, "Romance": 0, "Sobrenatural": 0, "Contemplativo": 0,
            "Drama": 0, "Emocional": 0, "Suspense": 0, "Pol√≠tico": 0, "Absurdo": 0 
        };

        const POSITIVE_WEIGHT = 2; // Peso base para tags amadas
        const NEGATIVE_WEIGHT = -3; // Peso base para tags odiadas
        const NEUTRAL_WEIGHT = 0.5; // Peso base para tags neutras
        const MAX_CHAR_LIMIT = 15000; // Limite de caracteres para a √°rea de texto de importa√ß√£o em massa


        /**
         * Exibe o overlay global de carregamento com uma mensagem personalizada.
         * @param {string} message - A mensagem a ser exibida.
         */
        function showGlobalLoading(message) {
            document.getElementById('global-loading-message').textContent = message;
            document.getElementById('global-loading-overlay').classList.remove('hidden');
        }
        window.showGlobalLoading = showGlobalLoading;

        /**
         * Esconde o overlay global de carregamento.
         */
        function hideGlobalLoading() {
            document.getElementById('global-loading-overlay').classList.add('hidden');
        }
        window.hideGlobalLoading = hideGlobalLoading;

        /**
         * Atualiza o contador de caracteres na √°rea de texto de importa√ß√£o em massa.
         * Tamb√©m TRUNCA o valor para o limite m√°ximo.
         */
        function updateCharCounter() {
            const textarea = document.getElementById('batch-anime-input');
            const counter = document.getElementById('char-count');
            const currentLength = textarea.value.length;
            const maxLength = parseInt(textarea.getAttribute('maxlength'));
            
            // TRUNCAMENTO: Bloqueia a digita√ß√£o ap√≥s o limite
            if (currentLength > maxLength) {
                textarea.value = textarea.value.substring(0, maxLength);
            }
            
            counter.textContent = `${textarea.value.length.toLocaleString('pt-BR')} / ${maxLength.toLocaleString('pt-BR')} caracteres`;

            // Muda a cor se estiver perto do limite (90%)
            if (textarea.value.length > maxLength * 0.9) {
                counter.classList.add('text-danger');
                counter.classList.remove('text-gray-500');
            } else {
                counter.classList.remove('text-danger');
                counter.classList.add('text-gray-500');
            }
        }
        window.updateCharCounter = updateCharCounter;

        /**
         * Abre o modal de explica√ß√£o.
         * @param {string} level - O n√≠vel do quiz ('simple', 'normal', 'pro').
         */
        function showExplanation(level) {
            const modalTitle = document.getElementById('explanation-title');
            const modalContent = document.getElementById('explanation-content');
            
            let title, content;

            switch (level) {
                case 'simple':
                    title = 'Filtro Simples (10 Animes)';
                    content = 'Avalie 10 animes que cobrem os g√™neros e elementos narrativos mais populares (A√ß√£o, Sombrio, Com√©dia). **Resultado:** Filtro de gosto b√°sico e r√°pido. Bom para quem tem prefer√™ncias claras.';
                    break;
                case 'normal':
                    title = 'Filtro Normal (20 Animes)';
                    content = 'Avalie 20 animes que cobrem uma ampla variedade de g√™neros e estilos (Sci-Fi, Mecha, Romance, Psicol√≥gico, etc.). **Resultado:** Filtro detalhado e preciso, ideal para a maioria dos usu√°rios.';
                    break;
                case 'pro':
                    title = 'Filtro Pro (50 Animes)';
                    content = 'Avalie 50 animes que cobrem todos os principais g√™neros e nichos (Horror, Esportes, Hist√≥rico, Sci-Fi complexo). **Resultado:** Filtro extremamente fino, capaz de distinguir gostos sutis. Recomendado para a m√°xima precis√£o.';
                    break;
                default:
                    title = 'Informa√ß√£o';
                    content = 'N√≠vel de quiz desconhecido.';
            }

            modalTitle.textContent = title;
            modalContent.innerHTML = content;
            document.getElementById('explanation-modal').classList.remove('hidden');
        }
        window.showExplanation = showExplanation;

        /**
         * Fecha o modal de explica√ß√£o.
         */
        function closeExplanationModal() {
            document.getElementById('explanation-modal').classList.add('hidden');
        }
        window.closeExplanationModal = closeExplanationModal;

        /**
         * Exibe feedback na √°rea de previs√£o.
         * @param {string} title - T√≠tulo da mensagem.
         * @param {string} message - Corpo da mensagem.
         * @param {string} score - Pontua√ß√£o (opcional).
         */
        function displayFeedback(title, message, score = '') {
            document.getElementById('prediction-title').textContent = title;
            document.getElementById('prediction-score').textContent = score;
            document.getElementById('prediction-justification').innerHTML = message;
            document.getElementById('prediction-result').classList.remove('hidden');
        }

        /**
         * Alterna entre as abas e atualiza a UI.
         * @param {string} tabId - O ID da aba a ser exibida ('prediction', 'list', 'block').
         */
        function changeTab(tabId) {
            activeTab = tabId;
            const tabContents = document.querySelectorAll('#main-tabs-screen .tab-content');
            const tabButtons = document.querySelectorAll('.tab-button');

            tabContents.forEach(content => content.classList.add('hidden'));
            tabButtons.forEach(button => {
                if(button) button.classList.remove('active');
            });

            const targetScreen = document.getElementById(`${tabId}-tab-screen`);
            if (targetScreen) targetScreen.classList.remove('hidden');

            const activeButton = document.querySelector(`.tab-button[onclick="changeTab('${tabId}')"]`);
            if (activeButton) activeButton.classList.add('active');
            
            // Renderiza a lista de bloqueio quando a aba √© ativada
            if (tabId === 'block') {
                updateBlockListDisplay();
            }
        }
        window.changeTab = changeTab;
        

        /**
         * Inicializa o Firebase e o processo de autentica√ß√£o.
         */
        async function initFirebase() {
            try {
                if (!FIREBASE_CONFIG || !FIREBASE_CONFIG.projectId) {
                    throw new Error("Firebase config not available. Please add your credentials inside the script tag.");
                }
                app = initializeApp(FIREBASE_CONFIG);
                db = getFirestore(app);
                auth = getAuth(app);
                
                let initialSignInAttempted = false;

                // 1. Configura o listener para carregar o perfil quando o estado de autentica√ß√£o mudar
                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        userId = user.uid;
                        document.getElementById('user-id-display').textContent = `ID do Usu√°rio: ${userId}`;
                        isAuthReady = true;
                        loadUserFilter();
                    } else if (!initialSignInAttempted) {
                        // Se n√£o h√° usu√°rio e o primeiro login n√£o foi tentado (para iniciar a sess√£o)
                        attemptInitialSignIn();
                    } else {
                         // Se tentamos o login e falhou, mostra a tela inicial
                         showScreen('start-screen');
                    }
                });

                // 2. Tenta o login inicial (Custom Token ou An√¥nimo) se a sess√£o ainda n√£o carregou
                async function attemptInitialSignIn() {
                    initialSignInAttempted = true;
                    showScreen('loading-state');
                    try {
                        // N√£o h√° token customizado em ambientes de produ√ß√£o
                        await signInAnonymously(auth);
                    } catch (error) {
                        console.error("Erro no login inicial (An√¥nimo):", error);
                        // Se o login an√¥nimo falhar (ex: por regras de seguran√ßa), mostramos a tela inicial
                        document.getElementById('loading-state').innerHTML = `<p class="text-danger">Erro ao conectar o perfil. Verifique as regras do Firestore e se a Autentica√ß√£o An√¥nima est√° habilitada. [${error.message}]</p>`;
                        showScreen('start-screen');
                    }
                }
                
            } catch (error) {
                console.error("Erro na inicializa√ß√£o do Firebase ou autentica√ß√£o:", error);
                document.getElementById('loading-state').innerHTML = `<p class="text-danger">ERRO CR√çTICO: Configura√ß√£o do Firebase ausente ou inv√°lida. [${error.message}]</p>`;
                showScreen('start-screen');
            }
        }
        window.initFirebase = initFirebase; // Expor para uso global


        /**
         * Carrega o filtro do usu√°rio (se existir) do Firestore.
         */
        function loadUserFilter() {
            if (!isAuthReady) return;

            showScreen('loading-state');
            // O caminho usa o userId, garantindo que o perfil certo seja carregado, 
            // seja ele an√¥nimo (persistente no dispositivo)
            const docRef = doc(db, `artifacts/${appId}/users/${userId}/anime_filters`, 'profile');
            
            // Usa getDoc para carregar os dados uma vez, evitando race conditions do onSnapshot em testes.
            getDoc(docRef).then((docSnap) => {
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    userFilter = data.filterData;
                    watchedAnimes = data.watchedAnimes || [];
                    blockedAnimes = data.blockedAnimes || [];
                    
                    console.log("Filtro carregado via getDoc:", userFilter);
                    updateWatchedListDisplay();
                    updateBlockListDisplay();
                    showScreen('main-tabs-screen');
                    changeTab(activeTab);
                } else {
                    console.log("Nenhum filtro encontrado. Come√ßando question√°rio.");
                    watchedAnimes = [];
                    blockedAnimes = [];
                    updateWatchedListDisplay();
                    updateBlockListDisplay();
                    showScreen('start-screen');
                }
            }).catch((error) => {
                console.error("Erro ao carregar filtro com getDoc:", error);
                showScreen('start-screen');
            });
        }

        // --- Fun√ß√µes de Display de Lista ---

        /**
         * Atualiza o display da lista de animes assistidos na tela de previs√£o (resumo).
         */
        function updateWatchedListDisplay() {
            const listEl = document.getElementById('watched-list');
            const countEl = document.getElementById('watched-count');
            
            if (watchedAnimes.length === 0) {
                countEl.textContent = 'Animes Assistidos (0):';
                listEl.innerHTML = '<li class="text-sm text-gray-500">Nenhum anime salvo.</li>';
                return;
            }

            countEl.textContent = `Animes Assistidos (${watchedAnimes.length}):`;
            // Exibe apenas os primeiros 5 no resumo da tela principal
            listEl.innerHTML = watchedAnimes.slice(0, 5).map(anime => 
                `<li class="text-sm bg-primary text-white p-1 px-3 rounded-full shadow-md inline-block m-1">${anime}</li>`
            ).join('');
        }
        window.updateWatchedListDisplay = updateWatchedListDisplay;

        /**
         * Atualiza o display da lista de animes bloqueados na aba Bloqueio (resumo).
         */
        function updateBlockListDisplay() {
            const listEl = document.getElementById('blocked-list-summary');
            const countEl = document.getElementById('blocked-count');
            
            if (blockedAnimes.length === 0) {
                countEl.textContent = 'Animes Bloqueados (0):';
                listEl.innerHTML = '<li class="text-sm text-gray-500">Nenhum anime bloqueado.</li>';
                return;
            }

            countEl.textContent = `Animes Bloqueados (${blockedAnimes.length}):`;
            // Exibe apenas os primeiros 5 no resumo da tela principal
            listEl.innerHTML = blockedAnimes.slice(0, 5).map(anime => 
                `<li class="text-sm bg-danger text-white p-1 px-3 rounded-full shadow-md inline-block m-1">${anime}</li>`
            ).join('');
        }
        window.updateBlockListDisplay = updateBlockListDisplay;

        // --- Fun√ß√µes de Gerenciamento de Lista (Modal Assistidos) ---
        
        /**
         * Renderiza a lista detalhada de animes assistidos no modal, aplicando o filtro de busca.
         * @param {string} filterText - O texto de busca.
         */
        function renderDetailedWatchedList(filterText = '') {
            const detailedListEl = document.getElementById('detailed-watched-list');
            const lowerFilter = filterText.toLowerCase().trim();
            
            // 1. Filtra a lista com base no texto de busca
            const filteredAnimes = watchedAnimes.filter(anime => 
                anime.toLowerCase().includes(lowerFilter)
            ).sort(); // Opcional: mant√©m a lista ordenada alfabeticamente no modal

            if (watchedAnimes.length === 0) {
                detailedListEl.innerHTML = '<li class="text-md text-gray-500 text-center">Sua lista est√° vazia!</li>';
                return;
            }

            if (filteredAnimes.length === 0) {
                 detailedListEl.innerHTML = `<li class="text-md text-gray-500 text-center">Nenhum anime encontrado para "${filterText}".</li>`;
                 return;
            }

            // 2. Renderiza a lista filtrada
            detailedListEl.innerHTML = filteredAnimes.map(anime => 
                `
                <li class="flex justify-between items-center p-3 bg-gray-50 rounded-lg border">
                    <span class="text-dark font-medium">${anime}</span>
                    <button onclick="removeWatchedAnime('${anime.replace(/'/g, "\\'")}')" class="text-danger hover:text-red-700 font-bold ml-4 p-1 rounded-full hover:bg-red-100 transition duration-300" title="Remover">
                        &times;
                    </button>
                </li>
                `
            ).join('');
        }
        window.renderDetailedWatchedList = renderDetailedWatchedList;

        /**
         * Fun√ß√£o chamada no input do campo de busca para filtrar a lista.
         */
        function filterWatchedList() {
             const filterText = document.getElementById('watched-list-search').value;
             renderDetailedWatchedList(filterText);
        }
        window.filterWatchedList = filterWatchedList;


        /**
         * Abre o modal de gerenciamento.
         */
        function openWatchedListModal() {
            // Limpa e renderiza a lista completa ao abrir
            document.getElementById('watched-list-search').value = '';
            renderDetailedWatchedList(); 
            document.getElementById('watched-list-modal').classList.remove('hidden');
        }
        window.openWatchedListModal = openWatchedListModal;

        /**
         * Fecha o modal de gerenciamento.
         */
        function closeWatchedListModal() {
            document.getElementById('watched-list-modal').classList.add('hidden');
        }
        window.closeWatchedListModal = closeWatchedListModal;
        
        /**
         * Exporta a lista de animes assistidos para um arquivo PDF.
         */
        function exportToPDF() {
            if (watchedAnimes.length === 0) {
                displayFeedback('Lista Vazia', 'N√£o h√° animes para exportar para PDF.', '');
                return;
            }

            showGlobalLoading("Gerando o arquivo PDF, aguarde...");

            try {
                // Acessa a classe jsPDF na window
                const { jsPDF } = window.jspdf;
                // Instancia com tamanho A4 (padr√£o)
                const doc = new jsPDF(); 
                
                // Configura√ß√µes b√°sicas
                const title = "Minha Lista de Animes Assistidos";
                const date = new Date().toLocaleDateString('pt-BR');
                const lineHeight = 8; // Altura da linha reduzida para caber mais
                const marginX = 15;
                let y = 15;

                // --- T√≠tulo (Visual Aprimorado) ---
                doc.setFont("helvetica", "bold");
                doc.setFontSize(20);
                doc.setTextColor('#1D4ED8'); // Cor prim√°ria
                doc.text(title, doc.internal.pageSize.width / 2, y, { align: 'center' });
                y += lineHeight;

                // Linha divis√≥ria
                doc.setDrawColor('#1D4ED8');
                doc.setLineWidth(0.5);
                doc.line(10, y, doc.internal.pageSize.width - 10, y);
                y += lineHeight * 0.5;

                // --- Meta-informa√ß√µes ---
                doc.setFont("helvetica", "normal");
                doc.setFontSize(10);
                doc.setTextColor('#6C757D'); // Cor secund√°ria
                doc.text(`Gerado em: ${date}`, marginX, y);
                doc.text(`Total de Animes: ${watchedAnimes.length}`, doc.internal.pageSize.width - marginX, y, { align: 'right' });
                y += lineHeight * 1.5; // Espa√ßo antes da lista

                // --- Lista (Ordenada Alfabeticamente) ---
                doc.setFont("helvetica", "normal");
                doc.setFontSize(12);
                doc.setTextColor('#1F2937'); // Cor escura
                
                // ORDENA√á√ÉO ALFAB√âTICA
                const sortedList = watchedAnimes.sort((a, b) => a.localeCompare(b));
                
                sortedList.forEach((anime, index) => {
                    const text = `${index + 1}. ${anime}`;
                    
                    // Verifica se precisa de nova p√°gina
                    if (y > 280) { // Limite da p√°gina (A4)
                        doc.addPage();
                        y = 15;
                    }
                    
                    doc.text(text, marginX, y);
                    y += lineHeight;
                });

                // Salva o arquivo
                doc.save(`Minha_Lista_Animes_${date.replace(/\//g, '-')}.pdf`);
                displayFeedback('Exporta√ß√£o para PDF Conclu√≠da!', 'Seu arquivo PDF foi gerado e o download deve come√ßar em instantes.', '');

            } catch (e) {
                console.error("Erro ao gerar PDF: ", e);
                displayFeedback('Erro no PDF', 'Falha ao gerar o arquivo PDF. Verifique se o navegador permite pop-ups ou downloads.', '');
            } finally {
                hideGlobalLoading();
            }
        }
        window.exportToPDF = exportToPDF;


        /**
         * Remove um anime da lista de assistidos no estado local e no Firestore.
         */
        async function removeWatchedAnime(animeName) {
            const cleanAnimeName = animeName.replace(/'/g, '').trim();

            // 1. Remove localmente
            const initialLength = watchedAnimes.length;
            watchedAnimes = watchedAnimes.filter(a => a.toLowerCase() !== cleanAnimeName.toLowerCase());

            if (watchedAnimes.length === initialLength) {
                // N√£o encontrou o anime para remover
                return;
            }
            
            // 2. Update Firestore
            const docRef = doc(db, `artifacts/${appId}/users/${userId}/anime_filters`, 'profile');
            
            showGlobalLoading(`Removendo ${cleanAnimeName} e salvando lista...`);

            try {
                // Salva a lista filtrada no Firestore
                await setDoc(docRef, {
                    watchedAnimes: watchedAnimes,
                }, { merge: true });
                
                // 3. Atualiza a UI (ambos: modal e resumo)
                updateWatchedListDisplay(); 
                // Renderiza o modal novamente, mantendo o filtro de busca ativo
                filterWatchedList(); 
                displayFeedback('Removido', `${cleanAnimeName} foi removido da sua lista de assistidos.`, ''); // Feedback no principal

            } catch (e) {
                console.error("Erro ao remover e salvar lista de assistidos: ", e);
                // Se falhar ao salvar, melhor adicionar de volta localmente (rollback)
                watchedAnimes.push(cleanAnimeName);
                updateWatchedListDisplay(); 
                displayFeedback('Erro ao Salvar', 'Falha ao remover e salvar a lista no banco de dados. Tente novamente.', '');
            } finally {
                hideGlobalLoading();
            }
        }
        window.removeWatchedAnime = removeWatchedAnime;


        /**
         * Adiciona um anime √† lista de assistidos no estado local e no Firestore.
         */
        async function addToWatched(animeName) {
            const cleanAnimeName = animeName.replace(/'/g, '').trim();

            if (!cleanAnimeName || watchedAnimes.map(a => a.toLowerCase()).includes(cleanAnimeName.toLowerCase())) {
                displayFeedback(`${cleanAnimeName} j√° est√° na sua lista!`, 'O sistema lembrar√° de n√£o sugerir este anime.', '');
                return; 
            }

            // Remove da lista de bloqueio se estiver l√°
            if (blockedAnimes.map(a => a.toLowerCase()).includes(cleanAnimeName.toLowerCase())) {
                await unblockAnime(cleanAnimeName, false); // N√£o mostra loading pois ser√° coberto pelo save
            }

            watchedAnimes.push(cleanAnimeName);
            
            const docRef = doc(db, `artifacts/${appId}/users/${userId}/anime_filters`, 'profile');
            
            showGlobalLoading(`Adicionando ${cleanAnimeName} e salvando lista...`);
            
            try {
                await setDoc(docRef, {
                    watchedAnimes: watchedAnimes,
                    blockedAnimes: blockedAnimes // Salva a lista de bloqueio atualizada (caso tenha sido removido)
                }, { merge: true });
                
                updateWatchedListDisplay();
                updateBlockListDisplay(); // Atualiza display de bloqueio
                displayFeedback(`${cleanAnimeName} Adicionado!`, 'O sistema lembrar√° de n√£o sugerir este anime novamente.', '');

            } catch (e) {
                console.error("Erro ao salvar lista de assistidos: ", e);
                // Remove localmente se o save falhar
                watchedAnimes.pop();
                document.getElementById('prediction-title').textContent = 'Erro ao Salvar';
                document.getElementById('prediction-score').textContent = '';
                document.getElementById('prediction-justification').textContent = 'Falha ao salvar a lista no banco de dados. Tente novamente.';
                document.getElementById('prediction-result').classList.remove('hidden');
            } finally {
                hideGlobalLoading();
            }
        }
        window.addToWatched = addToWatched;
        
        // --- Fun√ß√µes de Gerenciamento de Lista (Modal Bloqueados) ---

        /**
         * Renderiza a lista detalhada de animes bloqueados no modal, aplicando o filtro de busca.
         * @param {string} filterText - O texto de busca.
         */
        function renderDetailedBlockList(filterText = '') {
            const detailedListEl = document.getElementById('detailed-block-list');
            const lowerFilter = filterText.toLowerCase().trim();
            
            // 1. Filtra a lista com base no texto de busca
            const filteredAnimes = blockedAnimes.filter(anime => 
                anime.toLowerCase().includes(lowerFilter)
            ).sort(); 

            if (blockedAnimes.length === 0) {
                detailedListEl.innerHTML = '<li class="text-md text-gray-500 text-center">Nenhum anime na lista de bloqueio.</li>';
                return;
            }

            if (filteredAnimes.length === 0) {
                 detailedListEl.innerHTML = `<li class="text-md text-gray-500 text-center">Nenhum anime encontrado para "${filterText}".</li>`;
                 return;
            }

            // 2. Renderiza a lista filtrada
            detailedListEl.innerHTML = filteredAnimes.map(anime => 
                `
                <li class="flex justify-between items-center p-3 bg-red-50 rounded-lg border border-red-200">
                    <span class="text-dark font-medium">${anime}</span>
                    <button onclick="unblockAnime('${anime.replace(/'/g, "\\'")}', true)" class="text-danger hover:text-red-700 font-bold ml-4 p-1 rounded-full hover:bg-red-200 transition duration-300" title="Desbloquear">
                        &times;
                    </button>
                </li>
                `
            ).join('');
        }
        window.renderDetailedBlockList = renderDetailedBlockList;
        
        /**
         * Fun√ß√£o chamada no input do campo de busca para filtrar a lista de bloqueio.
         */
        function filterBlockList() {
             const filterText = document.getElementById('block-list-search').value;
             renderDetailedBlockList(filterText);
        }
        window.filterBlockList = filterBlockList;

        /**
         * Abre o modal de gerenciamento de bloqueio.
         */
        function openBlockListModal() {
            document.getElementById('block-list-search').value = '';
            renderDetailedBlockList(); 
            document.getElementById('block-list-modal').classList.remove('hidden');
        }
        window.openBlockListModal = openBlockListModal;

        /**
         * Fecha o modal de gerenciamento de bloqueio.
         */
        function closeBlockListModal() {
            document.getElementById('block-list-modal').classList.add('hidden');
        }
        window.closeBlockListModal = closeBlockListModal;

        /**
         * Adiciona um anime √† lista de bloqueio e ATUALIZA o filtro de gosto com base nas tags do anime.
         */
        async function blockAnime(animeName, shouldShowLoading = true) {
            const cleanAnimeName = animeName.replace(/'/g, '').trim();

            if (!cleanAnimeName || blockedAnimes.map(a => a.toLowerCase()).includes(cleanAnimeName.toLowerCase())) {
                displayFeedback(`${cleanAnimeName} j√° est√° bloqueado!`, 'O sistema j√° sabe para n√£o sugerir este anime.', '');
                return;
            }

            if (!userFilter) {
                displayFeedback('Filtro Inexistente', 'Voc√™ precisa criar um filtro antes de poder bloque√°-lo e nos ensinar o que voc√™ n√£o gosta.', '');
                return;
            }

            if (shouldShowLoading) showGlobalLoading(`Analisando e bloqueando ${cleanAnimeName}...`);

            try {
                // 1. Obter as tags do anime para aprender com elas
                const analysisQuery = `Analise o anime "${cleanAnimeName}". Use o Google Search para encontrar informa√ß√µes e retorne APENAS um objeto JSON. O objeto deve conter "tags": um array com as tags/elementos mais fortes (use as tags: ${Object.keys(tagWeights).join(', ')}). Retorne APENAS o objeto JSON.`;
                const analysisData = await callGeminiAPI(analysisQuery, false);
                const animeTags = analysisData.tags || [];

                // 2. Aplicar uma forte penalidade no filtro do usu√°rio para cada tag encontrada
                if (animeTags.length > 0) {
                    animeTags.forEach(tag => {
                        if (userFilter[tag] !== undefined) {
                            // Aplica uma penalidade forte, similar a uma nota 0 no quiz
                            userFilter[tag] += NEGATIVE_WEIGHT * 2;
                        }
                    });
                     // Normaliza os pesos para evitar n√∫meros muito grandes
                    Object.keys(userFilter).forEach(tag => {
                        userFilter[tag] = parseFloat(userFilter[tag].toFixed(1));
                    });
                }

                // 3. Atualizar as listas locais
                // Remove da lista de assistidos se estiver l√°
                const wasWatched = watchedAnimes.map(a => a.toLowerCase()).includes(cleanAnimeName.toLowerCase());
                if (wasWatched) {
                    watchedAnimes = watchedAnimes.filter(a => a.toLowerCase() !== cleanAnimeName.toLowerCase());
                }

                blockedAnimes.push(cleanAnimeName);

                // 4. Salvar tudo (filtro atualizado e listas) no Firestore em uma √∫nica opera√ß√£o
                const docRef = doc(db, `artifacts/${appId}/users/${userId}/anime_filters`, 'profile');
                await setDoc(docRef, {
                    filterData: userFilter,
                    blockedAnimes: blockedAnimes,
                    watchedAnimes: watchedAnimes
                }, { merge: true });

                // 5. Atualizar a UI e fornecer feedback
                updateBlockListDisplay();
                updateWatchedListDisplay();
                if (shouldShowLoading) {
                    const feedbackMessage = animeTags.length > 0
                        ? `Este anime e outros com elementos de ${animeTags.join(', ')} ser√£o menos recomendados.`
                        : 'Este anime n√£o ser√° mais sugerido.';
                    displayFeedback(`${cleanAnimeName} Bloqueado!`, feedbackMessage, 'üö´');
                }

            } catch (error) {
                console.error("Erro ao analisar e bloquear o anime:", error);
                if (shouldShowLoading) displayFeedback('Erro no Bloqueio', `N√£o foi poss√≠vel analisar e bloquear o anime. ${error.message}`, '');
                // Como a opera√ß√£o pode ter falhado no meio, n√£o revertemos o estado local para evitar inconsist√™ncia.
                // O usu√°rio pode tentar novamente.
            } finally {
                if (shouldShowLoading) hideGlobalLoading();
            }
        }
        window.blockAnime = blockAnime;

        /**
         * Remove um anime da lista de bloqueio.
         */
        async function unblockAnime(animeName, shouldShowLoading = true) {
            const cleanAnimeName = animeName.replace(/'/g, '').trim();
            
            const initialLength = blockedAnimes.length;
            blockedAnimes = blockedAnimes.filter(a => a.toLowerCase() !== cleanAnimeName.toLowerCase());

            if (blockedAnimes.length === initialLength) {
                return;
            }
            
            const docRef = doc(db, `artifacts/${appId}/users/${userId}/anime_filters`, 'profile');
            if (shouldShowLoading) showGlobalLoading(`Desbloqueando ${cleanAnimeName} e salvando lista...`);

            try {
                await setDoc(docRef, {
                    blockedAnimes: blockedAnimes,
                }, { merge: true });
                
                updateBlockListDisplay();
                if (shouldShowLoading) {
                    renderDetailedBlockList(document.getElementById('block-list-search')?.value || '');
                    displayFeedback('Desbloqueado', `${cleanAnimeName} pode ser sugerido novamente.`, '');
                }

            } catch (e) {
                console.error("Erro ao salvar lista de bloqueio: ", e);
                blockedAnimes.push(cleanAnimeName); // Rollback
                if (shouldShowLoading) displayFeedback('Erro ao Salvar', 'Falha ao salvar a lista no banco de dados. Tente novamente.', '');
            } finally {
                if (shouldShowLoading) hideGlobalLoading();
            }
        }
        window.unblockAnime = unblockAnime;

        /**
         * Bloqueia um anime manualmente pelo input.
         */
        async function blockAnimeFromInput() {
            const inputEl = document.getElementById('manual-block-input');
            const animeName = inputEl.value.trim();
            inputEl.value = '';
            if (animeName) {
                await blockAnime(animeName, true);
                changeTab('block'); // Volta para a aba de bloqueio
            }
        }
        window.blockAnimeFromInput = blockAnimeFromInput;


        /**
         * Exporta a lista de animes assistidos, copiando para a √°rea de transfer√™ncia.
         */
        async function exportWatchedList() {
            if (watchedAnimes.length === 0) {
                displayFeedback('Lista Vazia', 'N√£o h√° animes para exportar.', '');
                return;
            }

            const listString = watchedAnimes.join(', ');

            // Tenta copiar usando a API moderna (pode falhar no iframe)
            if (navigator.clipboard && navigator.clipboard.writeText) {
                try {
                    await navigator.clipboard.writeText(listString);
                    displayFeedback('Sucesso!', 'A lista foi copiada para a √°rea de transfer√™ncia. Voc√™ pode col√°-la em qualquer lugar.', '');
                    return;
                } catch (err) {
                    console.warn('Falha ao usar navigator.clipboard, usando fallback.', err);
                    // Continua para o fallback
                }
            }

            // Fallback: Cria um textarea tempor√°rio e usa document.execCommand('copy')
            const tempTextArea = document.createElement('textarea');
            tempTextArea.value = listString;
            document.body.appendChild(tempTextArea);
            tempTextArea.select();
            
            try {
                document.execCommand('copy');
                displayFeedback('Sucesso!', 'A lista foi copiada para a √°rea de transfer√™ncia. Voc√™ pode col√°-la em qualquer lugar.', '');
            } catch (err) {
                console.error('Falha na c√≥pia com fallback.', err);
                displayFeedback('Erro na C√≥pia', 'N√£o foi poss√≠vel copiar automaticamente. A lista est√° na mensagem abaixo para c√≥pia manual.', `Lista: ${listString}`);
            } finally {
                document.body.removeChild(tempTextArea);
            }
        }
        window.exportWatchedList = exportWatchedList;

        /**
         * Core logic to process raw text (from textarea or JSON file)
         * @param {string} rawText - Raw, potentially messy text containing anime titles.
         */
        async function processBatchImport(rawText) {
            const loadingDiv = document.getElementById('loading-prediction');
            const resultDiv = document.getElementById('prediction-result');

            resultDiv.classList.add('hidden');
            loadingDiv.classList.remove('hidden');
            toggleButtons(true); // Desabilita bot√µes
            
            showGlobalLoading("Processando e limpando sua lista de animes, aguarde...");

            let cleanTitles = [];
            
            try {
                // 1. Chamar a API para limpar o texto e extrair apenas os nomes dos animes.
                const cleaningQuery = `Analise o texto desorganizado abaixo e extraia APENAS os t√≠tulos de animes v√°lidos. Ignore n√∫meros, anos, g√™neros, nomes de usu√°rio e lixo. Retorne APENAS um objeto JSON com uma chave "titles" contendo um array de strings. Texto para an√°lise:\n\n${rawText}`;

                const cleanResult = await callGeminiAPI(cleaningQuery, false, 'data-cleaner');
                cleanTitles = cleanResult.titles || [];

                if (cleanTitles.length === 0) {
                    displayFeedback('Nenhuma Novidade', 'O Sistema de An√°lise n√£o conseguiu identificar nenhum t√≠tulo de anime v√°lido no texto colado. Verifique o formato.', '');
                    return;
                }

                // 2. Processar a lista limpa e verificar duplicatas
                const newAnimes = [];
                const existingAnimeLower = watchedAnimes.map(a => a.toLowerCase());
                const existingBlockedLower = blockedAnimes.map(a => a.toLowerCase());


                cleanTitles.forEach(title => {
                    const cleanTitle = title.replace(/'/g, '').trim();
                    if (cleanTitle && cleanTitle.length > 3 && !existingAnimeLower.includes(cleanTitle.toLowerCase())) {
                        newAnimes.push(cleanTitle);
                        watchedAnimes.push(cleanTitle); 
                        existingAnimeLower.push(cleanTitle.toLowerCase());
                        
                        // Se estiver bloqueado, remove da lista de bloqueio
                         if(existingBlockedLower.includes(cleanTitle.toLowerCase())) {
                            blockedAnimes = blockedAnimes.filter(a => a.toLowerCase() !== cleanTitle.toLowerCase());
                         }
                    }
                });

                if (newAnimes.length === 0) {
                    displayFeedback('Nenhuma Novidade', 'Todos os animes colados j√° estavam na sua lista ou o formato estava incorreto.', '');
                    return;
                }
                
                // 3. Salvar o array completo no Firestore (opera√ß√£o √∫nica)
                const docRef = doc(db, `artifacts/${appId}/users/${userId}/anime_filters`, 'profile');
                
                showGlobalLoading(`Salvando ${newAnimes.length} novos animes...`);
                
                await setDoc(docRef, {
                    watchedAnimes: watchedAnimes,
                    blockedAnimes: blockedAnimes
                }, { merge: true });
                
                updateWatchedListDisplay();
                updateBlockListDisplay(); // Atualiza display de bloqueio

                const newAnimesForFeedback = newAnimes.slice(0, 5).join(', ') + (newAnimes.length > 5 ? '...' : '');

                displayFeedback('Importa√ß√£o Conclu√≠da!', `Foram adicionados **${newAnimes.length}** novos animes √† sua lista.`, `Novos animes: ${newAnimesForFeedback}`);

            } catch (e) {
                console.error("Erro no processamento da lista em massa: ", e);
                displayFeedback('Erro ao Salvar em Massa', `Falha ao processar e salvar a lista no banco de dados. Erro: ${e.message}`, '');
            } finally {
                loadingDiv.classList.add('hidden');
                toggleButtons(false); // Habilita bot√µes
                hideGlobalLoading();
            }
        }

        /**
         * Adiciona uma grande quantidade de animes √† lista de assistidos (via input de texto).
         */
        async function batchAddWatchedAnimes() {
            const inputEl = document.getElementById('batch-anime-input');
            const rawText = inputEl.value.trim();
            inputEl.value = ''; // Limpa o campo de entrada
            updateCharCounter(); // Reinicia o contador de caracteres

            if (!rawText) {
                displayFeedback('Erro', 'Por favor, cole nomes de animes na caixa de texto.', '');
                return;
            }
            
            await processBatchImport(rawText);
        }
        window.batchAddWatchedAnimes = batchAddWatchedAnimes;


        /**
         * Exibe a tela correta e esconde as outras.
         */
        function showScreen(screenId) {
            const screens = ['loading-state', 'start-screen', 'quiz-screen', 'main-tabs-screen'];
            screens.forEach(id => {
                const screen = document.getElementById(id);
                if (screen) {
                    screen.classList.add('hidden');
                }
            });
            const targetScreen = document.getElementById(screenId);
            if (targetScreen) {
                targetScreen.classList.remove('hidden');
            }
        }
        window.showScreen = showScreen;

        /**
         * Inicia o quiz, gerando dinamicamente os inputs.
         * @param {string} level - O n√≠vel do quiz ('simple', 'normal', 'pro').
         */
        function startQuiz(level) {
            let dataLength;
            if (level === 'simple') {
                dataLength = 10;
            } else if (level === 'normal') {
                dataLength = 20;
            } else if (level === 'pro') {
                dataLength = 50; // AGORA PEGA OS 50 ANIME
            } else {
                dataLength = 10; // Padr√£o
            }

            // Seleciona o subconjunto de dados para o quiz
            currentQuizData = allQuizData.slice(0, dataLength);


            const form = document.getElementById('quiz-form');
            form.innerHTML = '';
            
            currentQuizData.forEach((item, index) => {
                const questionHtml = `
                    <div class="mb-4 p-3 border border-gray-300 rounded-xl shadow-sm bg-gray-50" id="question-container-${index}">
                        <div class="flex justify-between items-center mb-2">
                            <label for="rating-${index}" class="block text-lg font-medium text-dark">${item.name}</label>
                            <label class="text-xs text-gray-500 flex items-center">
                                <input type="checkbox" id="not-watched-${index}" onchange="toggleRating(${index})" class="mr-1 h-4 w-4 rounded border-gray-300 text-primary focus:ring-primary">
                                N√£o Assisti
                            </label>
                        </div>
                        <p class="text-sm text-gray-500 mb-2">${item.description}</p>
                        <input type="range" id="rating-${index}" name="rating-${index}" min="0" max="10" value="5" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer range-lg">
                        <div class="flex justify-between text-sm mt-1">
                            <span class="text-danger">0</span>
                            <span id="value-${index}" class="font-bold text-lg text-primary">5</span>
                            <span class="text-success">10</span>
                        </div>
                    </div>
                `;
                form.innerHTML += questionHtml;
            });

            // Adiciona listeners para atualizar os valores de range
            currentQuizData.forEach((_, index) => {
                document.getElementById(`rating-${index}`).addEventListener('input', (event) => {
                    document.getElementById(`value-${index}`).textContent = event.target.value;
                });
            });

            showScreen('quiz-screen');
        }
        window.startQuiz = startQuiz;


        /**
         * Habilita/desabilita o controle de rating baseado no checkbox "N√£o Assisti".
         * @param {number} index - O √≠ndice da quest√£o do quiz.
         */
        function toggleRating(index) {
            const checkbox = document.getElementById(`not-watched-${index}`);
            const ratingInput = document.getElementById(`rating-${index}`);
            const questionContainer = document.getElementById(`question-container-${index}`);
            const valueDisplay = document.getElementById(`value-${index}`);

            if (checkbox.checked) {
                ratingInput.disabled = true;
                questionContainer.classList.add('opacity-50');
                valueDisplay.textContent = '-';
            } else {
                ratingInput.disabled = false;
                questionContainer.classList.remove('opacity-50');
                valueDisplay.textContent = ratingInput.value;
            }
        }
        window.toggleRating = toggleRating;

        /**
         * Calcula o filtro e o salva no Firestore.
         */
        async function submitRatings() {
            const ratings = [];
            let ratedAnimesCount = 0;

            currentQuizData.forEach((item, index) => {
                const checkbox = document.getElementById(`not-watched-${index}`);
                if (!checkbox.checked) {
                    const input = document.getElementById(`rating-${index}`);
                    ratings.push({ rating: parseInt(input.value), anime: item });
                    ratedAnimesCount++;
                }
            });

            if (ratedAnimesCount === 0) {
                displayFeedback('Nenhuma Avalia√ß√£o', 'Voc√™ precisa avaliar pelo menos um anime para criar seu filtro.', '');
                return;
            }

            // --- 1. Calcular Pesos do Filtro ---
            const calculatedWeights = { ...tagWeights };
            ratings.forEach(ratedItem => {
                const { rating, anime } = ratedItem;
                const scoreDelta = rating - 5;

                anime.tags.forEach(tag => {
                    if (rating >= 8) {
                        calculatedWeights[tag] += POSITIVE_WEIGHT;
                    } else if (rating <= 2) {
                        calculatedWeights[tag] += NEGATIVE_WEIGHT * 2;
                    } else if (rating < 5) {
                        calculatedWeights[tag] += NEGATIVE_WEIGHT / 2;
                    } else if (rating > 5) {
                        calculatedWeights[tag] += NEUTRAL_WEIGHT;
                    }
                });
            });
            
            Object.keys(calculatedWeights).forEach(tag => {
                calculatedWeights[tag] = parseFloat(calculatedWeights[tag].toFixed(1));
            });

            userFilter = calculatedWeights;

            // --- 2. Salvar no Firestore ---
            showGlobalLoading("Gerando e salvando seu filtro, aguarde!");

            const docRef = doc(db, `artifacts/${appId}/users/${userId}/anime_filters`, 'profile');
            try {
                await setDoc(docRef, {
                    userId: userId,
                    ratings: ratings.map(r => ({ anime: r.anime.name, rating: r.rating })), // Salva de forma mais limpa
                    filterData: userFilter,
                    watchedAnimes: watchedAnimes,
                    blockedAnimes: blockedAnimes,
                    timestamp: new Date().toISOString()
                }, { merge: true });
                console.log("Filtro salvo com sucesso!");
                
                showScreen('main-tabs-screen');
                changeTab('prediction'); 
            } catch (e) {
                console.error("Erro ao salvar o filtro: ", e);
                showScreen('main-tabs-screen');
                changeTab('prediction'); 
            } finally {
                hideGlobalLoading();
            }
        }
        window.submitRatings = submitRatings;

        // --- Fun√ß√£o para habilitar/desabilitar os bot√µes de previs√£o ---
        function toggleButtons(disabled) {
            const buttons = document.querySelectorAll('#prediction-tab-screen button');
            // Os primeiros dois bot√µes s√£o Prever Gosto e Sugest√£o Aleat√≥ria
            if(buttons.length >= 2) {
                buttons[0].disabled = disabled;
                buttons[1].disabled = disabled;
                // Altera a cor para indicar o estado desabilitado
                if(disabled) {
                    buttons[0].classList.add('opacity-50', 'cursor-not-allowed');
                    buttons[1].classList.add('opacity-50', 'cursor-not-allowed');
                } else {
                    buttons[0].classList.remove('opacity-50', 'cursor-not-allowed');
                    buttons[1].classList.remove('opacity-50', 'cursor-not-allowed');
                }
            }
        }

        // --- Fun√ß√£o Central de Chamada da API Gemini (Mantida gen√©rica) ---
        async function callGeminiAPI(query, isRecommendation = false, systemInstructionType = 'default') {
            const tagsList = Object.keys(tagWeights).join(', ');
            
            // Define a instru√ß√£o do sistema com base no tipo de tarefa
            let systemInstructionText;
            let useSearchTool = true;

            if (systemInstructionType === 'data-cleaner') {
                 systemInstructionText = "Voc√™ √© um limpador de dados especializado. Seu √∫nico trabalho √© extrair APENAS os t√≠tulos de animes de um texto desorganizado e retorn√°-los em um array JSON com a chave 'titles'. Sua √öNICA SA√çDA DEVE SER UM OBJETO JSON BEM FORMADO.";
                 useSearchTool = false; // N√£o precisa de busca para limpar texto
            } else {
                 systemInstructionText = "Voc√™ √© um analista de animes focado em extrair tags de g√™nero e elementos narrativos. Sua √öNICA SA√çDA DEVE SER UM OBJETO JSON BEM FORMADO.";
                 useSearchTool = true; // Precisa de busca para analisar animes
            }

            // Se for recomenda√ß√£o, ajusta a query
            if (isRecommendation) {
                const topTags = getTopPositiveTags().join(', ');
                
                // Exclui a lista fixa (quiz) e a lista din√¢mica de assistidos E BLOQUEADOS
                const fixedExcluded = allQuizData.map(d => d.name); // Exclui todos os 50 animes do quiz
                const excludedAnimes = [...fixedExcluded, ...watchedAnimes, ...blockedAnimes].join(', ');
                
                query = `Encontre um anime que N√ÉO seja: ${excludedAnimes}. O anime deve conter as tags de g√™nero e elementos narrativos: ${topTags}. Retorne APENAS um objeto JSON. O objeto deve conter: 1) "anime": Nome do Anime. 2) "tags": Array com as tags de g√™nero/elementos (use tags: ${tagsList}). 3) "sinopse": Uma breve sinopse (1 frase). Retorne APENAS o objeto JSON.`;
            }

            const apiKey = GEMINI_API_KEY; // AGORA USA A CHAVE DO USU√ÅRIO
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

            const payload = {
                contents: [{ parts: [{ text: query }] }],
                systemInstruction: {
                    parts: [{ text: systemInstructionText }]
                }
            };

            // Adiciona a ferramenta de busca se necess√°rio
            if (useSearchTool) {
                payload.tools = [{ "google_search": {} }];
            }

            let jsonResponse;
            
            // Define o objeto 'options' para a requisi√ß√£o fetch
            const options = {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            };

            try {
                const response = await fetchWithBackoff(apiUrl, options);

                const result = await response.json();
                let jsonText = result.candidates?.[0]?.content?.parts?.[0]?.text;
                
                if (!jsonText || typeof jsonText !== 'string' || jsonText.trim().length === 0) {
                    throw new Error("API de An√°lise: Resposta vazia ou inv√°lida.");
                }
                
                try {
                    // LIMPEZA AGRESSIVA: remove delimitadores de markdown, espa√ßos e novas linhas
                    jsonText = jsonText.replace(/```json|```|\n/g, '').trim(); 
                    
                    // Isolar o bloco JSON puro: encontra o primeiro { e o √∫ltimo }
                    const startIndex = jsonText.indexOf('{');
                    const endIndex = jsonText.lastIndexOf('}');
                    
                    if (startIndex !== -1 && endIndex !== -1 && endIndex > startIndex) {
                        const jsonString = jsonText.substring(startIndex, endIndex + 1);
                        jsonResponse = JSON.parse(jsonString.trim());
                        return jsonResponse;
                    } else {
                        throw new Error("N√£o foi poss√≠vel isolar um bloco JSON v√°lido no texto de resposta.");
                    }
                } catch(parseError) {
                    console.error("Erro ao analisar o JSON:", parseError, "Texto Bruto:", jsonText);
                    throw new Error("API de An√°lise: Erro ao analisar a estrutura JSON retornada. O formato n√£o √© v√°lido.");
                }

            } catch (error) {
                throw new Error(error.message);
            }
        }

        // --- Fun√ß√£o de Recomenda√ß√£o ---

        /**
         * Encontra as top 3 tags positivas do filtro do usu√°rio.
         */
        function getTopPositiveTags() {
            if (!userFilter) return [];
            
            const sortedTags = Object.entries(userFilter)
                .filter(([tag, weight]) => weight > 0.5) // Filtra apenas tags com peso significativamente positivo
                .sort((a, b) => b[1] - a[1]) // Ordena do maior peso para o menor
                .slice(0, 3) // Pega as top 3
                .map(([tag]) => tag);
            
            // Retorna as 3 mais fortes ou algumas neutras se n√£o houver fortes
            if (sortedTags.length === 0) {
                 return ["A√ß√£o", "Fantasia", "Aventura"];
            }
            return sortedTags;
        }

        /**
         * Pede √† API uma sugest√£o de anime baseado no filtro do usu√°rio.
         */
        async function recommendAnime() {
            if (!userFilter) {
                displayFeedback('Erro', 'Por favor, gere seu filtro no question√°rio primeiro!', '');
                return;
            }

            const resultDiv = document.getElementById('prediction-result');
            resultDiv.classList.add('hidden');
            
            // MOSTRA O OVERLAY GLOBAL com mensagem espec√≠fica (SEM REFER√äNCIA √Ä IA)
            showGlobalLoading("Procurando um anime perfeito para voc√™! (Usando seu filtro de gosto)..."); 
            toggleButtons(true); // Desabilita bot√µes

            try {
                // isRecommendation = true, usa a l√≥gica de prompt de recomenda√ß√£o
                const recommendationData = await callGeminiAPI(null, true); 
                
                // Usa a fun√ß√£o applyPrediction para aplicar o filtro e exibir o resultado
                await applyPrediction(recommendationData, recommendationData.anime);

            } catch (error) {
                console.error("Erro na recomenda√ß√£o:", error);
                displayFeedback('Erro de Recomenda√ß√£o', `Falha ao gerar sugest√£o. ${error.message}`, '');
            } finally {
                toggleButtons(false); // Habilita bot√µes
                hideGlobalLoading(); // ESCONDE O OVERLAY GLOBAL
            }
        }
        window.recommendAnime = recommendAnime;

        /**
         * Aplica a l√≥gica de filtragem e exibe o resultado.
         */
        async function applyPrediction(jsonResponse, animeName) {
            const titleEl = document.getElementById('prediction-title');
            const scoreEl = document.getElementById('prediction-score');
            const justificationEl = document.getElementById('prediction-justification');
            const resultDiv = document.getElementById('prediction-result');
            
            const cleanAnimeName = animeName.replace(/'/g, '').trim();
            const lowerCaseAnimeName = cleanAnimeName.toLowerCase();

            const isWatched = watchedAnimes.map(a => a.toLowerCase()).includes(lowerCaseAnimeName);
            const isBlocked = blockedAnimes.map(a => a.toLowerCase()).includes(lowerCaseAnimeName);

            // Se estiver bloqueado, mostra a mensagem de bloqueio e para a execu√ß√£o.
            if (isBlocked) {
                displayFeedback('Anime Bloqueado', `Voc√™ bloqueou ${cleanAnimeName}. N√£o podemos analisar este t√≠tulo.`, 'üö´');
                justificationEl.innerHTML += `
                    <div class="mt-6 pt-4 border-t border-gray-200 p-3 bg-red-100 rounded-xl flex items-center justify-between shadow-md">
                        <p class="text-sm text-danger font-semibold flex items-center">
                            üö´ Voc√™ marcou que n√£o gostou deste anime.
                        </p>
                         <button onclick="unblockAnime('${cleanAnimeName.replace(/'/g, "\\'")}', true)" class="bg-secondary hover:bg-gray-700 text-white font-bold py-1 px-3 rounded-lg transition duration-300 text-xs shadow-sm">
                            Desfazer
                        </button>
                    </div>`;
                return;
            }

            const animeTags = jsonResponse.tags || [];
            let finalScore = 0;
            const positiveMatches = [];
            const negativeMatches = [];

            animeTags.forEach(tag => {
                const normalizedTag = Object.keys(userFilter).find(key => 
                    tag.toLowerCase().includes(key.toLowerCase()) || 
                    key.toLowerCase().includes(tag.toLowerCase())
                );
                
                if (normalizedTag && userFilter[normalizedTag] !== undefined) {
                    const weight = userFilter[normalizedTag];
                    finalScore += weight;

                    if (weight > 0) positiveMatches.push({ tag: normalizedTag, weight: weight });
                    else if (weight < 0) negativeMatches.push({ tag: normalizedTag, weight: weight });
                }
            });

            const maxPositiveScore = 15;
            const minNegativeScore = -15;
            let likelihood = Math.round(((finalScore - minNegativeScore) / (maxPositiveScore - minNegativeScore)) * 100);
            likelihood = Math.max(0, Math.min(100, likelihood)); 

            titleEl.textContent = `Previs√£o para ${cleanAnimeName}`;
            scoreEl.textContent = `${likelihood}% de Chance de Gostar`;
            
            let verdictText, matchDetailsText, colorClass;

            if (likelihood >= 75) {
                verdictText = 'ALTA COMPATIBILIDADE!';
                matchDetailsText = `O sistema detectou que voc√™ gosta muito de elementos como <strong>${positiveMatches.map(m => m.tag).slice(0, 3).join(', ')}</strong>. √â uma √≥tima aposta para seu pr√≥ximo anime.`;
                colorClass = 'bg-success/10 border-success text-success';
            } else if (likelihood >= 50) {
                verdictText = 'COMPATIBILIDADE MODERADA.';
                matchDetailsText = 'O anime tem pontos que se encaixam no seu perfil, mas pode faltar o peso dram√°tico ou a a√ß√£o intensa que voc√™ adora.';
                colorClass = 'bg-warning/10 border-warning text-yellow-600';
            } else if (likelihood >= 25) {
                verdictText = 'BAIXA COMPATIBILIDADE.';
                matchDetailsText = 'Embora haja tags que voc√™ tolera, ele toca em elementos que voc√™ tende a evitar.';
                colorClass = 'bg-danger/10 border-danger text-danger';
            } else {
                verdictText = 'MUITO BAIXA COMPATIBILIDADE (BLOQUEIO)!';
                matchDetailsText = `O sistema acionou o filtro de bloqueio! Elementos como <strong>${negativeMatches.map(m => m.tag).slice(0, 3).join(', ')}</strong> tiveram uma forte penalidade. √â um risco.`;
                colorClass = 'bg-danger/10 border-danger text-danger';
            }
            
            let justificationHtml = `
                <div class="space-y-4">
                    <div>
                        <p class="font-bold text-dark mb-1 flex items-center"><span class="text-lg mr-2">üìñ</span> Sinopse:</p>
                        <p class="text-sm text-gray-700 p-2 border-l-4 border-gray-300 bg-white shadow-inner rounded-r-md">${jsonResponse.sinopse || 'N√£o foi poss√≠vel obter uma sinopse.'}</p>
                    </div>
                    <div>
                        <p class="font-bold text-dark mb-1 flex items-center"><span class="text-lg mr-2">üéØ</span> Veredito do Sistema:</p>
                        <div class="p-4 rounded-xl shadow-md border-2 ${colorClass.split(' ').filter(c => c.startsWith('border-')).join(' ')} ${colorClass.split(' ').filter(c => c.startsWith('bg-')).join(' ')}">
                            <p class="font-extrabold text-lg ${colorClass.split(' ').filter(c => c.startsWith('text-')).join(' ')}">${verdictText}</p>
                            <p class="text-sm mt-2 text-gray-700">${matchDetailsText}</p>
                        </div>
                    </div>
                    <div>
                        <p class="font-bold text-dark mb-1 flex items-center"><span class="text-lg mr-2">üè∑Ô∏è</span> Tags de G√™nero Encontradas:</p>
                        <p class="text-xs mt-1 text-gray-600">${animeTags.join(', ') || 'Nenhuma tag encontrada.'}</p>
                    </div>
                </div>`;
            
            let actionButtonHtml = '';

            if (!isWatched) {
                actionButtonHtml = `
                    <div class="mt-6 pt-4 border-t border-gray-200 flex gap-4">
                        <button onclick="likeAnime('${cleanAnimeName.replace(/'/g, "\\'")}')" class="flex-1 bg-success hover:bg-green-600 text-white font-bold py-2 px-4 rounded-xl transition duration-300 shadow-md">Gostei üëç</button>
                        <button onclick="blockAnime('${cleanAnimeName.replace(/'/g, "\\'")}', true)" class="flex-1 bg-danger hover:bg-red-600 text-white font-bold py-2 px-4 rounded-xl transition duration-300 shadow-md">N√£o Gostei üëé</button>
                    </div>`;
            } else {
                actionButtonHtml = `
                    <div class="mt-6 pt-4 border-t border-gray-200 p-3 bg-green-100 rounded-xl flex items-center justify-between shadow-md">
                        <p class="text-sm text-success font-semibold flex items-center">‚úÖ Voc√™ j√° marcou que gostou deste anime!</p>
                        <button onclick="removeWatchedAnime('${cleanAnimeName.replace(/'/g, "\\'")}')" class="bg-secondary hover:bg-gray-700 text-white font-bold py-1 px-3 rounded-lg transition duration-300 text-xs shadow-sm">Remover</button>
                    </div>`;
            }

            justificationEl.innerHTML = justificationHtml + actionButtonHtml;
            resultDiv.classList.remove('hidden');
        }

        /**
         * Adiciona um anime √† lista de "Gostei" (assistidos) e ATUALIZA o filtro de gosto.
         */
        async function likeAnime(animeName) {
            const cleanAnimeName = animeName.replace(/'/g, '').trim();

            if (!userFilter) {
                displayFeedback('Filtro Inexistente', 'Voc√™ precisa criar um filtro antes de poder curtir um anime.', '');
                return;
            }
            if (watchedAnimes.map(a => a.toLowerCase()).includes(cleanAnimeName.toLowerCase())) {
                displayFeedback('J√° Curtiu!', 'Este anime j√° est√° na sua lista de animes que voc√™ gostou.', '');
                return;
            }

            showGlobalLoading(`Analisando e salvando ${cleanAnimeName}...`);

            try {
                // 1. Obter as tags do anime para aprender com elas
                const analysisQuery = `Analise o anime "${cleanAnimeName}". Use o Google Search para encontrar informa√ß√µes e retorne APENAS um objeto JSON. O objeto deve conter "tags": um array com as tags/elementos mais fortes (use as tags: ${Object.keys(tagWeights).join(', ')}), e "sinopse": "Uma breve sinopse (1 frase)". Retorne APENAS o objeto JSON.`;
                const analysisData = await callGeminiAPI(analysisQuery, false);
                const animeTags = analysisData.tags || [];

                // 2. Aplicar um refor√ßo positivo no filtro do usu√°rio para cada tag encontrada
                if (animeTags.length > 0) {
                    animeTags.forEach(tag => {
                        if (userFilter[tag] !== undefined) {
                            // Aplica um refor√ßo positivo, similar a uma nota alta no quiz
                            userFilter[tag] += POSITIVE_WEIGHT;
                        }
                    });
                    Object.keys(userFilter).forEach(tag => {
                        userFilter[tag] = parseFloat(userFilter[tag].toFixed(1));
                    });
                }

                // 3. Atualizar as listas locais
                watchedAnimes.push(cleanAnimeName);
                blockedAnimes = blockedAnimes.filter(a => a.toLowerCase() !== cleanAnimeName.toLowerCase());

                // 4. Salvar tudo no Firestore
                const docRef = doc(db, `artifacts/${appId}/users/${userId}/anime_filters`, 'profile');
                await setDoc(docRef, {
                    filterData: userFilter,
                    watchedAnimes: watchedAnimes,
                    blockedAnimes: blockedAnimes
                }, { merge: true });

                // 5. Atualizar a UI para refletir o novo estado
                updateWatchedListDisplay();
                updateBlockListDisplay();
                // Re-renderiza o card de previs√£o para mostrar que o anime foi adicionado
                await applyPrediction(analysisData, cleanAnimeName);
                // Fornece um feedback claro na parte superior
                displayFeedback(`${cleanAnimeName} Adicionado!`, 'Seu filtro foi aprimorado com base nesta escolha.', 'üëç');


            } catch (error) {
                console.error("Erro ao curtir e analisar o anime:", error);
                displayFeedback('Erro ao Curtir', `N√£o foi poss√≠vel analisar e salvar o anime. ${error.message}`, '');
            } finally {
                hideGlobalLoading();
            }
        }
        window.likeAnime = likeAnime;


        /**
         * Chama a API Gemini para obter sinopse e aplicar o filtro.
         */
        async function predictAnime() {
            const animeName = document.getElementById('anime-input').value.trim();
            const resultDiv = document.getElementById('prediction-result');


            if (!animeName || !userFilter) {
                displayFeedback('Erro', 'Por favor, digite o nome de um anime e certifique-se de que seu filtro foi gerado.', '');
                return;
            }

            resultDiv.classList.add('hidden');
            // MOSTRA O OVERLAY GLOBAL com mensagem espec√≠fica (SEM REFER√äNCIA √Ä IA)
            showGlobalLoading(`Analisando o gosto para ${animeName} (usando o Sistema de An√°lise e Busca)...`);
            toggleButtons(true); // Desabilita bot√µes

            const predictionQuery = `Analise o anime "${animeName}". Use o Google Search para encontrar informa√ß√µes e retorne APENAS um objeto JSON. O objeto deve conter: 1) "anime": Nome do anime. 2) "tags": Um array com as tags/elementos mais fortes (use as tags: ${Object.keys(tagWeights).join(', ')}). 3) "sinopse": Uma breve sinopse (1 frase). Retorne APENAS o objeto JSON.`;

            try {
                const predictionData = await callGeminiAPI(predictionQuery, false);
                await applyPrediction(predictionData, predictionData.anime);
            } catch (error) {
                console.error("Erro na predi√ß√£o:", error);
                const errorMessage = error.message.includes("API Gemini")
                    ? error.message
                    : 'N√£o foi poss√≠vel analisar este anime. Tente novamente ou verifique a ortografia. (Erro de Comunica√ß√£o da API)';

                displayFeedback('Erro de An√°lise', errorMessage, '');

            } finally {
                toggleButtons(false); // Habilita bot√µes
                hideGlobalLoading(); // ESCONDE O OVERLAY GLOBAL
            }
        }
        window.predictAnime = predictAnime;

        /**
         * Implementa√ß√£o simples de Exponential Backoff para chamadas de API.
         */
        async function fetchWithBackoff(url, options, maxRetries = 5) {
            for (let i = 0; i < maxRetries; i++) {
                try {
                    const response = await fetch(url, options);
                    if (response.status !== 429) {
                        return response;
                    }
                    // Se for 429 (Too Many Requests), espera e tenta novamente
                    const delay = Math.pow(2, i) * 1000 + Math.random() * 1000;
                    await new Promise(resolve => setTimeout(resolve, delay));
                } catch (error) {
                    // Ignorar erros de rede e tentar novamente
                    const delay = Math.pow(2, i) * 1000 + Math.random() * 1000;
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
            throw new Error("Falha na chamada da API ap√≥s v√°rias tentativas.");
        }

        /**
         * Reseta o aplicativo para o estado inicial do quiz.
         */
        function resetApp() {
            userFilter = null;
            document.getElementById('prediction-result').classList.add('hidden');
            document.getElementById('anime-input').value = '';
            showScreen('start-screen');
        }
        window.resetApp = resetApp;

        // Inicia o aplicativo ao carregar a p√°gina
        window.onload = initFirebase;
    </script>
</body>
</html>
